{"version":3,"sources":["../src/permit.ts","../src/hook.ts","../src/abi.ts"],"names":["signature","error"],"mappings":"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","sourcesContent":["import { Hex, hexToNumber, pad, slice, toHex, TypedDataDomain } from \"viem\";\nimport type { WalletClient } from \"wagmi\";\n\nexport type PermitSignature = {\n\tr: Hex;\n\ts: Hex;\n\tv: number;\n};\n\nexport type SignPermitProps = {\n\t/** Address of the token to approve */\n\tcontractAddress: Hex;\n\t/** Name of the token to approve.\n\t * Corresponds to the `name` method on the ERC-20 contract. Please note this must match exactly byte-for-byte */\n\terc20Name: string;\n\t/** Owner of the tokens. Usually the currently connected address. */\n\townerAddress: Hex;\n\t/** Address to grant allowance to */\n\tspenderAddress: Hex;\n\t/** Expiration of this approval, in SECONDS */\n\tdeadline: bigint;\n\t/** Numerical chainId of the token contract */\n\tchainId: number;\n\t/** Defaults to 1. Some tokens need a different version, check the [PERMIT INFORMATION](https://github.com/vacekj/wagmi-permit/blob/main/PERMIT.md) for more information */\n\tpermitVersion?: string;\n\t/** Permit nonce for the specific address and token contract. You can get the nonce from the `nonces` method on the token contract. */\n\tnonce: bigint;\n};\n\nexport type Eip2612Props = SignPermitProps & {\n\t/** Amount to approve */\n\tvalue: bigint;\n};\n\n/**\n * Signs a permit for a given ERC-2612 ERC20 token using the specified parameters.\n *\n * @param {WalletClient} walletClient - Wallet client to invoke for signing the permit message\n * @param {SignPermitProps} props - The properties required to sign the permit.\n * @param {string} props.contractAddress - The address of the ERC20 token contract.\n * @param {string} props.erc20Name - The name of the ERC20 token.\n * @param {number} props.value - The amount of the ERC20 to approve.\n * @param {string} props.ownerAddress - The address of the token holder.\n * @param {string} props.spenderAddress - The address of the token spender.\n * @param {number} props.deadline - The permit expiration timestamp in seconds.\n * @param {number} props.nonce - The nonce of the address on the specified ERC20.\n * @param {number} props.chainId - The chain ID for which the permit will be valid.\n * @param {number} props.permitVersion - The version of the permit (optional, defaults to \"1\").\n */\nexport const signPermit = async (\n\twalletClient: WalletClient,\n\t{\n\t\tcontractAddress,\n\t\terc20Name,\n\t\townerAddress,\n\t\tspenderAddress,\n\t\tvalue,\n\t\tdeadline,\n\t\tnonce,\n\t\tchainId,\n\t\tpermitVersion,\n\t}: Eip2612Props,\n): Promise<PermitSignature> => {\n\tconst types = {\n\t\tPermit: [\n\t\t\t{ name: \"owner\", type: \"address\" },\n\t\t\t{ name: \"spender\", type: \"address\" },\n\t\t\t{ name: \"value\", type: \"uint256\" },\n\t\t\t{ name: \"nonce\", type: \"uint256\" },\n\t\t\t{ name: \"deadline\", type: \"uint256\" },\n\t\t],\n\t};\n\n\tconst domainData = {\n\t\tname: erc20Name,\n\t\t/** We assume 1 if permit version is not specified */\n\t\tversion: permitVersion ?? \"1\",\n\t\tchainId: chainId,\n\t\tverifyingContract: contractAddress,\n\t};\n\n\tconst message = {\n\t\towner: ownerAddress,\n\t\tspender: spenderAddress,\n\t\tvalue,\n\t\tnonce,\n\t\tdeadline,\n\t};\n\n\tconst signature = await walletClient.signTypedData({\n\t\taccount: ownerAddress,\n\t\tmessage,\n\t\tdomain: domainData,\n\t\tprimaryType: \"Permit\",\n\t\ttypes,\n\t});\n\tconst [r, s, v] = [\n\t\tslice(signature, 0, 32),\n\t\tslice(signature, 32, 64),\n\t\tslice(signature, 64, 65),\n\t];\n\treturn { r, s, v: hexToNumber(v) };\n};\n\nexport const signPermitDai =\n\t/**\n\t * Signs a permit for a given ERC20 token using the specified parameters.\n\t *\n\t * @param {WalletClient} walletClient - \tWallet client to invoke for signing the permit message\n\t * @param {SignPermitProps} props - The properties required to sign the permit.\n\t * @param {string} props.contractAddress - The address of the ERC20 token contract.\n\t * @param {string} props.erc20Name - The name of the ERC20 token.\n\t * @param {string} props.ownerAddress - The address of the token holder.\n\t * @param {string} props.spenderAddress - The address of the token spender.\n\t * @param {number} props.deadline - The permit expiration timestamp in seconds.\n\t * @param {number} props.nonce - The nonce of the address on the specified ERC20.\n\t * @param {number} props.chainId - The chain ID for which the permit will be valid.\n\t * @param {number} props.permitVersion - The version of the permit (optional, defaults to \"1\").\n\t */\n\tasync (\n\t\twalletClient: WalletClient,\n\t\t{\n\t\t\tcontractAddress,\n\t\t\terc20Name,\n\t\t\townerAddress,\n\t\t\tspenderAddress,\n\t\t\tdeadline,\n\t\t\tnonce,\n\t\t\tchainId,\n\t\t\tpermitVersion,\n\t\t}: SignPermitProps,\n\t): Promise<PermitSignature> => {\n\t\tconst types = {\n\t\t\tPermit: [\n\t\t\t\t{ name: \"holder\", type: \"address\" },\n\t\t\t\t{ name: \"spender\", type: \"address\" },\n\t\t\t\t{ name: \"nonce\", type: \"uint256\" },\n\t\t\t\t{ name: \"expiry\", type: \"uint256\" },\n\t\t\t\t{ name: \"allowed\", type: \"bool\" },\n\t\t\t],\n\t\t};\n\n\t\tlet domainData: TypedDataDomain = {\n\t\t\tname: erc20Name,\n\t\t\t/** There are no known Dai deployments with Dai permit and version other than or unspecified */\n\t\t\tversion: permitVersion ?? \"1\",\n\t\t\tchainId: chainId,\n\t\t\tverifyingContract: contractAddress,\n\t\t};\n\t\t/** USDC on Polygon is a special case */\n\t\tif (chainId === 137 && erc20Name === \"USD Coin (PoS)\") {\n\t\t\tdomainData = {\n\t\t\t\tname: erc20Name,\n\t\t\t\tversion: permitVersion ?? \"1\",\n\t\t\t\tverifyingContract: contractAddress,\n\t\t\t\tsalt: pad(toHex(137), { size: 32 }),\n\t\t\t};\n\t\t}\n\n\t\tconst message = {\n\t\t\tholder: ownerAddress,\n\t\t\tspender: spenderAddress,\n\t\t\tnonce,\n\t\t\texpiry: deadline,\n\t\t\t/** true == infinite allowance, false == 0 allowance*/\n\t\t\tallowed: true,\n\t\t};\n\n\t\tconst signature = await walletClient.signTypedData({\n\t\t\taccount: ownerAddress,\n\t\t\tdomain: domainData,\n\t\t\tprimaryType: \"Permit\",\n\t\t\ttypes,\n\t\t\tmessage,\n\t\t});\n\t\tconst [r, s, v] = [\n\t\t\tslice(signature, 0, 32),\n\t\t\tslice(signature, 32, 64),\n\t\t\tslice(signature, 64, 65),\n\t\t];\n\t\treturn { r, s, v: hexToNumber(v) };\n\t};\n","import {\n  Eip2612Props,\n  PermitSignature,\n  SignPermitProps,\n  signPermit,\n  signPermitDai,\n} from './permit.js';\nimport { WalletClient, useContractRead, useWalletClient } from 'wagmi';\n\nimport { ERC20ABI } from './abi.js';\nimport { useState } from 'react';\nimport { zeroAddress } from 'viem';\n\nexport function usePermit({\n  contractAddress,\n  chainId,\n  walletClient,\n  ownerAddress,\n  spenderAddress,\n  permitVersion,\n}: UsePermitProps) {\n  const [signature, setSignature] = useState<PermitSignature | undefined>();\n  const [error, setError] = useState<Error>();\n\n  const { data: defaultWalletClient } = useWalletClient();\n  const walletClientToUse = walletClient ?? defaultWalletClient;\n  const ownerToUse =\n    ownerAddress ?? walletClientToUse?.account.address ?? zeroAddress;\n  const { data: nonce } = useContractRead({\n    chainId,\n    address: contractAddress,\n    abi: ERC20ABI,\n    functionName: 'nonces',\n    args: [ownerToUse],\n  });\n  const { data: name } = useContractRead({\n    chainId,\n    address: contractAddress,\n    abi: ERC20ABI,\n    functionName: 'name',\n  });\n  const { data: versionFromContract } = useContractRead({\n    chainId,\n    address: contractAddress,\n    abi: ERC20ABI,\n    functionName: 'version',\n  });\n\n  const validatedVersionFromContract =\n    versionFromContract != null &&\n    [1, 2, '1', '2'].includes(versionFromContract)\n      ? versionFromContract\n      : null;\n\n  const version = permitVersion ?? validatedVersionFromContract ?? '1';\n\n  const ready =\n    walletClientToUse !== null &&\n    walletClientToUse !== undefined &&\n    spenderAddress !== undefined &&\n    chainId !== undefined &&\n    contractAddress !== undefined &&\n    name !== undefined &&\n    nonce !== undefined;\n\n  return {\n    signPermitDai: ready\n      ? async (\n          props: PartialBy<\n            SignPermitProps,\n            | 'chainId'\n            | 'ownerAddress'\n            | 'contractAddress'\n            | 'spenderAddress'\n            | 'nonce'\n            | 'erc20Name'\n            | 'permitVersion'\n          > & {\n            walletClient?: WalletClient;\n          }\n        ) =>\n          signPermitDai(props.walletClient ?? walletClientToUse, {\n            chainId,\n            ownerAddress:\n              ownerAddress ??\n              props.walletClient?.account.address ??\n              walletClientToUse.account.address,\n            contractAddress: contractAddress,\n            spenderAddress: spenderAddress ?? zeroAddress,\n            erc20Name: name,\n            permitVersion: version,\n            nonce,\n            ...props,\n          })\n            .then((signature) => {\n              setSignature(signature);\n              return signature;\n            })\n            .catch((error) => {\n              setError(error);\n              throw error;\n            })\n      : undefined,\n    signPermit: ready\n      ? async (\n          props: PartialBy<\n            Eip2612Props,\n            | 'chainId'\n            | 'ownerAddress'\n            | 'contractAddress'\n            | 'spenderAddress'\n            | 'nonce'\n            | 'erc20Name'\n            | 'permitVersion'\n          > & {\n            walletClient?: WalletClient;\n          }\n        ) => {\n          try {\n            const signature = await signPermit(\n              props.walletClient ?? walletClientToUse,\n              {\n                chainId,\n                ownerAddress:\n                  ownerAddress ??\n                  props.walletClient?.account.address ??\n                  walletClientToUse.account.address,\n                contractAddress: contractAddress,\n                spenderAddress: spenderAddress ?? zeroAddress,\n                erc20Name: name,\n                nonce,\n                permitVersion: version,\n                ...props,\n              }\n            );\n            setSignature(signature);\n            return signature;\n          } catch (error) {\n            setError(error as Error);\n            throw error;\n          }\n        }\n      : undefined,\n    signature,\n    error,\n  };\n}\n\nexport type UsePermitProps = Partial<SignPermitProps> & {\n  walletClient?: WalletClient | null;\n};\n\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n","export const ERC20ABI = [\n\t{\n\t\tinputs: [],\n\t\tstateMutability: \"view\",\n\t\ttype: \"function\",\n\t\tname: \"name\",\n\t\toutputs: [\n\t\t\t{\n\t\t\t\tinternalType: \"string\",\n\t\t\t\tname: \"\",\n\t\t\t\ttype: \"string\",\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tinputs: [\n\t\t\t{\n\t\t\t\tinternalType: \"address\",\n\t\t\t\tname: \"owner\",\n\t\t\t\ttype: \"address\",\n\t\t\t},\n\t\t],\n\t\tstateMutability: \"view\",\n\t\ttype: \"function\",\n\t\tname: \"nonces\",\n\t\toutputs: [\n\t\t\t{\n\t\t\t\tinternalType: \"uint256\",\n\t\t\t\tname: \"\",\n\t\t\t\ttype: \"uint256\",\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tinputs: [],\n\t\tname: \"version\",\n\t\toutputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n\t\tstateMutability: \"view\",\n\t\ttype: \"function\",\n\t},\n] as const;\n"]}